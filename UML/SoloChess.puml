@startuml

interface Observable {
    +addObserver(observer: Observer): void
    +notifyObservers(): void
}

interface Observer {
    +update(): void
}

class Point {
    +x: int
    +y: int
    +equals(obj: Object): boolean
    +hashCode(): int
    +toString(): String
    +isWithinBounds(boardSize: int): boolean
    +toChessNotation(boardSize: int): String
}

abstract class Tile {
    #position: Point
    #isDefended: boolean
    +Tile(position: Point)
    +isOccupied(): boolean
    +getPosition(): Point
    +isDefended(): boolean
    +setDefended(defended: boolean): void
    +setPiece(piece: Piece): void
    +getPiece(): Piece
    +removePiece(): void
}

class EmptyTile extends Tile {
    +EmptyTile(position: Point)
    +isOccupied(): boolean
    +setPiece(piece: Piece): void
    +getPiece(): Piece
    +removePiece(): void
}

class OccupiedTile extends Tile {
    -piece: Piece
    +OccupiedTile(position: Point, piece: Piece)
    +getPiece(): Piece
    +setPiece(piece: Piece): void
    +removePiece(): void
    +isOccupied(): boolean
}

abstract class Piece {
    #color: String
    #position: Point
    +Piece(color: String, position: Point)
    +getPossibleMoves(board: Board): List<Point>
    +getColor(): String
    +getPosition(): Point
    +move(newPosition: Point, boardSize: int): void
    +toString(): String
}

class King extends Piece {
    +getPossibleMoves(board: Board): List<Point>
}

class Queen extends Piece {
    +getPossibleMoves(board: Board): List<Point>
}

class Bishop extends Piece {
    +getPossibleMoves(board: Board): List<Point>
}

class Rook extends Piece {
    +getPossibleMoves(board: Board): List<Point>
}

class Board implements Observable {
    -tiles: Tile[][]
    -rows: int
    -columns: int
    +initializeBoard(): void
    +placePiece(piece: Piece, position: Point): void
    +removePiece(position: Point): void
    +getTileAt(position: Point): Tile
    +isWithinBounds(position: Point): boolean
    +addObserver(observer: Observer): void
    +notifyObservers(): void
}

class PieceFactory {
    +createPiece(type: String, color: String, position: Point): Piece
}

class Renderer implements Observer {
    +update(): void
    +render(batch: SpriteBatch, board: Board): void
}

class Controller {
    -board: Board
    -gameState: GameStateInterface
    +handleInput(input: Input): void
    +update(deltaTime: float): void
}

interface GameStateInterface {
    +update(deltaTime: float): void
    +render(batch: SpriteBatch): void
}

class PlayingState implements GameStateInterface {
    +update(deltaTime: float): void
    +render(batch: SpriteBatch): void
}

class PausedState implements GameStateInterface {
    +update(deltaTime: float): void
    +render(batch: SpriteBatch): void
}

class GameOverState implements GameStateInterface {
    +update(deltaTime: float): void
    +render(batch: SpriteBatch): void
}

class TiledLoader {
    +loadTiledMap(mapPath: String): TiledMap
    +parseLayer(layerName: String): List<Tile>
    +extractPieces(layerName: String): List<Piece>
}

class TiledMap {
    +getLayer(layerName: String): TiledLayer
}

class TiledLayer {
    +getTiles(): List<Tile>
    +getCustomProperties(): Map<String, String>
}

GameManager *-- Board
GameManager *-- GameStateInterface
GameManager *-- Controller

PieceFactory ..> Piece
Renderer ..> Board
Controller ..> Board
Controller ..> GameStateInterface
Board ..|> Observable
Renderer ..|> Observer
GameStateInterface <|.. PlayingState
GameStateInterface <|.. PausedState
GameStateInterface <|.. GameOverState
TiledLoader ..> TiledMap
TiledMap ..> TiledLayer
TiledLoader ..> Board
TiledLoader ..> PieceFactory

@enduml
